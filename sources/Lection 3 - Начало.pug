section
	h4 Haskell
	ul
		li Лаконичность
		li Строгая типизация
		li Модульность
		li Функции — объекты первого порядка
		li Отсутствие побочных эффектов
		li Ленивые вычисления

section
	h4 Синтаксис. Числа.
	pre
		code.haskell.
			> 2 + 2
			4

			> 6 / 5
			1.2

			> 6 / -5
			Precedence parsing error
				cannot mix `/' [infixl 7] and prefix `-' [infixl 6]
				in the same infix expression
			> 6 / (-5)
			-1.2

section
	h4 Синтаксис. Булеан.
	pre
		code.haskell.
			> True || False
			True

			> True && False
			False

			> not False
			True

			> 2 * 2 == 4
			True

			> 2 * 2 /= 5
			True
		code.haskell.fragment.
			> 2 == "два"	?

section
	h4 Это вам не js и не c
	pre
		code.
			<interactive>:56:1:
			No instance for (Num [Char])
				arising from the literal `2'
			Possible fix: add an instance declaration for (Num [Char])
			In the first argument of `(==)', namely `2'
			In the expression: 2 == "sad"
			In an equation for `it': it = 2 == "sad"

section
	h4 Типы (:set +t)
	p Всегда с большой буквы
	ul
		li Integer, Int
		li Float, Double
		li Bool (True, False) (алгебраический тип)
		li Char

section
	h4 Типы (:set +t)
	pre
		code.haskell.
			> :set +t
			> 42
			42 it :: Integer

			> 3.1415
			> True

			> :t 42
			42 :: Num a => a
				(параметрический, специальный (ad hoc) полиморфизм)

			42 + 1.2
			it :: Double

			> :t 42 + 8.2
			42 + 8.2 :: Fractional a => a

section
	h4 Функции
	pre
		code.haskell.
			> succ 9
			10
			> max 2.5 5.6
			5.6
			> 2 + max 2.5 5.6 + min 3.4 (succ 4)
			11.0
			> 2 + (max 2.5 5.6) + (min 3.4 (succ 4))

			Ассоциативность слева, справа

			2 ** 2 ** 3 / (2 ** 2) ** 3/  2 ** (2 ** 3)
			2 - 2 – 2  ?

section
	h4 Функции
	p Напишите выражение, высчитывающее минимальное число среди 10, 2, 5, -1, 99

section
	h4 Опять факториал
	p lab1.hs
	pre
		code.haskell.
			fac 0 = 1
			fac n = n * fac (n-1)
	p console
	pre
		code.haskell.
			> ghci
			> :load ~lab1.hs
			> fac 6
			720
			> let a = 20
			> fac a
			2432902008176640000

section
	h4 Что происходит
	ul
		li Математика
		// Определение функции похоже на математическое определение факториала
		li.fragment Рассуждение
		// Рассуждение о программах: доказательство корректности, …
		li.fragment Рекурсия
		li.fragment Эффективность
		// При умелом программировании не ведет к падению эффективности (компилятор сводит к итерации)
		li.fragment Отсутствует оператор присваивания
		// Определения функций, (=) имеет другую семантику – связывание имен
		// Будучи один раз связанным, имя не может менять свое значение (в рамках области видимости)
		// Следствие: нет побочных эффектов

section
	h4 Простые функции
	pre
		code.haskell.
			succ' n = n + 1

			> succ' 9
			10

			square x = x * x

			> square 4
			16

			squareIfLess5 = if x < 5 then square x else x

			> squareIfLess5 3
			9
			> squareIfLess5 7
			7

section
	h4 Строки
	p Строка – это список символов
	pre
		code.hs.
			> "Марьванна"
			"Марьванна"
			it :: [Char]
		code.hs.fragment.
			> 'М':"арьванна"
			> ['М','а','р','ь','в','а','н','н','а']
			-- про списки ниже!
		code.hs.fragment.
			hello s = "Hello, " ++ s ++ "!"
			> hello "Марьванна"
			"Hello, \1052\1072\1088\1100\1074\1072\1085\1085\1072!"

section
	h4 Типы функций
	pre
		code.hs.
			> :t hello
			hello :: [Char] -> [Char]
		code.hs.fragment.
			> :t fac
			fac :: (Eq a, Num a) => a -> a
			-- ограничение - контекст (классы типов)
		code.hs.fragment.
			> :t max
			max :: Ord a => a -> a -> a
		code.hs.fragment.
			> :t squareIfLess5
			squareIfLess5 :: (Num a, Ord a) => a -> a